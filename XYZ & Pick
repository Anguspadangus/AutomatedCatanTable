# -*- coding: utf-8 -*-
"""
Created on Fri Jan 26 23:25:37 2024
@author: Owen Porpora
"""

import time
import board
import RPi.GPIO as GPIO
from adafruit_motorkit import MotorKit
from adafruit_motor import stepper

# Constants
track_length_x = 1000
track_length_y = 800
start_track_x = 0
start_track_y = 0
distance_per_step = 0.2  # Distance moved per step in mm
GATE_VALVE_PIN = 16      # Set the GPIO pin for the gate valve
blow_time = 1            # Blow time in seconds
suck_time = 3            # Suck time in seconds
pick_time = 10           # Pick time in seconds

# Initialize MotorKit
kit = MotorKit(i2c=board.I2C(0x60))
kit2 = MotorKit(i2c=board.I2C(0x61))

# Load current position from file
try:
    with open("current_position_gantry_x.txt", "r") as file:
        current_position_gantry_x = {'x': int(file.read())}
except FileNotFoundError:
    current_position_gantry_x = {'x': 0}
except Exception as e:
    print(f"Error reading current position file: {e}")
    # Handle the error or exit the program
    
try:
    with open("current_position_gantry_y.txt", "r") as file:
        current_position_gantry_y = {'y': int(file.read())}
except FileNotFoundError:
    current_position_gantry_y = {'y': 0}
except Exception as e:
    print(f"Error reading current position file: {e}")

try:
    with open("current_position_gripper_z.txt", "r") as file:
        current_position_gantry_z = {'z': int(file.read())}
except FileNotFoundError:
    current_position_gantry_z = {'z': 0}
except Exception as e:
    print(f"Error reading current position file: {e}")
    # Handle the error or exit the program

def set_gate_valve_low():
    GPIO.output(GATE_VALVE_PIN, GPIO.LOW)
    print("Gate Valve state low")

def set_gate_valve_high():
    GPIO.output(GATE_VALVE_PIN, GPIO.HIGH)
    print("Gate Valve state high")

def run_motor_with_timeout(motor, duration, action, specific_time):
    motor.throttle = 1
    start_time = time.time()
    print(f"{action} has begun at {time.strftime('%H:%M:%S', time.localtime(start_time))}")
    time.sleep(int(specific_time))  # Convert to integer
    motor.throttle = 0
    end_time = time.time()
    print(f"{action} has finished at {time.strftime('%H:%M:%S', time.localtime(end_time))}. Elapsed time: {end_time - start_time:.2f} seconds")


def pick(blow_motor, suck_motor, blow_time, suck_time, pick_time):
    set_gate_valve_low()
    run_motor_with_timeout(blow_motor, 1, "Blowing", blow_time)
    set_gate_valve_high()
    run_motor_with_timeout(suck_motor, 1, "Sucking", suck_time)
    time.sleep(pick_time)

# Function to move to a specific (x, y, z) coordinate
def move_to(new_x, new_y):
    global current_position_gantry_x
    global current_position_gantry_y
    global current_position_gantry_z
    print(f"Last X position was location: {current_position_gantry_x['x']} mm")
    print(f"Last Y position was location: {current_position_gantry_y['y']} mm")
    print(f"Last Z position was location: {current_position_gantry_z['z']} mm")

    # Bound new_x and new_y within track limits
    new_x = max(start_track_x, min(new_x, track_length_x))
    new_y = max(start_track_y, min(new_y, track_length_y))

    # Calculate the relative movement required for X and Y
    x_distance = new_x - current_position_gantry_x['x']
    y_distance = new_y - current_position_gantry_y['y']

    print(f"delta X is: {x_distance} mm")
    print(f"delta Y is: {y_distance} mm")

    # Calculate the number of steps required for X and Y
    x_steps = int(abs(x_distance) / distance_per_step)
    y_steps = int(abs(y_distance) / distance_per_step)

    # Move both X and Y axis motors simultaneously
    try:
        for i in range(max(x_steps, y_steps)):
            if i < x_steps:
                if x_distance > 0:
                    kit.stepper1.onestep(direction=stepper.FORWARD, style=stepper.DOUBLE)
                elif x_distance < 0:
                    kit.stepper1.onestep(direction=stepper.BACKWARD, style=stepper.DOUBLE)
                else:
                    print("Motor X does not need to move")
            if i < y_steps:
                if y_distance > 0:
                    kit.stepper2.onestep(direction=stepper.FORWARD, style=stepper.DOUBLE)
                elif y_distance < 0:
                    kit.stepper2.onestep(direction=stepper.BACKWARD, style=stepper.DOUBLE)
                else:
                    print("Motor Y does not need to move")
            time.sleep(0.0001)
    except Exception as e:
        print(f"Error during motor movement: {e}")
        # Handle the error or exit the program

    # Move Z-axis down by 15 mm
    try:
        z_distance_down = -15
        z_steps_down = int(abs(z_distance_down) / distance_per_step)

        for i in range(z_steps_down):
            kit2.stepper1.onestep(direction=stepper.FORWARD, style=stepper.DOUBLE)
            time.sleep(0.0001)
    except Exception as e:
        print(f"Error during Z-axis down movement: {e}")
        # Handle the error or exit the program

    # Run the pick sequence
    try:
        pick(kit.motor_M1, kit.motor_M1, blow_time, suck_time, pick_time)
    except Exception as e:
        print(f"Error during pick sequence: {e}")
        # Handle the error or exit the program

    # Move Z-axis back up by 15 mm
    try:
        z_distance_up = 15
        z_steps_up = int(abs(z_distance_up) / distance_per_step)

        for i in range(z_steps_up):
            kit2.stepper1.onestep(direction=stepper.BACKWARD, style=stepper.DOUBLE)
            time.sleep(0.0001)
    except Exception as e:
        print(f"Error during Z-axis up movement: {e}")
        # Handle the error or exit the program

    # Update the current position
    current_position_gantry_x['x'] = new_x
    current_position_gantry_y['y'] = new_y
    current_position_gantry_z['z'] += (z_distance_down + z_distance_up)  # Corrected line
    print(f"Updated X position: {current_position_gantry_x['x']} mm")
    print(f"Updated Y position: {current_position_gantry_y['y']} mm")
    print(f"Updated Z position: {current_position_gantry_z['z']} mm")

    # Save current position to file
    try:
        with open("current_position_gantry_x.txt", "w") as file_x:
            file_x.write(str(current_position_gantry_x['x']))
        with open("current_position_gantry_y.txt", "w") as file_y:
            file_y.write(str(current_position_gantry_y['y']))
        with open("current_position_gripper_z.txt", "w") as file_z:
            file_z.write(str(current_position_gantry_z['z']))
    except Exception as e:
        print(f"Error writing current position files: {e}")

# Input lists of absolute positions for X and Y
positions_list_x = input("Enter a list of X positions (comma-separated) in millimeters: ").split(',')
positions_list_y = input("Enter a list of Y positions (comma-separated) in millimeters: ").split(',')

# Check if the input lists have the same length
if len(positions_list_x) != len(positions_list_y):
    print("Error: X and Y position lists must have the same length.")
    # Handle the error or exit the program
else:
    # Convert string values to integers
    positions_list_x = [int(position_x) for position_x in positions_list_x]
    positions_list_y = [int(position_y) for position_y in positions_list_y]

    # Move to each position in the lists sequentially
    for new_x, new_y in zip(positions_list_x, positions_list_y):
        move_to(new_x, new_y)
        time.sleep(5)  # Wait for 5 seconds between movements
