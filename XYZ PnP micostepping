# -*- coding: utf-8 -*-
"""
Created on Thu Feb  1 15:02:56 2024
@author: Owen Porpora
"""

import time
import RPi.GPIO as GPIO
from adafruit_motorkit import MotorKit
from adafruit_motor import stepper

# Constants
track_length_x = 1000
track_length_y = 800
start_track_x = 0
start_track_y = 0
distance_per_step = 0.2  # Distance moved per step in mm
GATE_VALVE_PIN = 16  # Set the GPIO pin for the gate valve
blow_time = 1  # Blow time in seconds
suck_time = 3  # Suck time in seconds
move_to_place_time = 10  # Pick time in seconds
place_x = 25
place_y = 50
home_x = 0
home_y = 0 
z_distance = 0

# Define the GPIO pin for the gate valve
GATE_VALVE_PIN = 17  # You should replace this with the actual GPIO pin number you are using

# Setup GPIO mode
GPIO.setmode(GPIO.BCM)
GPIO.setup(GATE_VALVE_PIN, GPIO.OUT)

# Initialize MotorKit
kit1 = MotorKit()
kit2 = MotorKit(address=0x61)

# Load current position from file
try:
    with open("current_position_gantry_x.txt", "r") as file:
        current_position_gantry_x = {'x': int(file.read())}
except FileNotFoundError:
    current_position_gantry_x = {'x': 0}
except Exception as e:
    print(f"Error reading current position file: {e}")
    # Handle the error or exit the program

try:
    with open("current_position_gantry_y.txt", "r") as file:
        current_position_gantry_y = {'y': int(file.read())}
except FileNotFoundError:
    current_position_gantry_y = {'y': 0}
except Exception as e:
    print(f"Error reading current position file: {e}")

try:
    with open("current_position_gripper_z.txt", "r") as file:
        current_position_gantry_z = {'z': int(file.read())}
except FileNotFoundError:
    current_position_gantry_z = {'z': 0}
except Exception as e:
    print(f"Error reading current position file: {e}")
    # Handle the error or exit the program

def set_gate_valve_low():
    GPIO.output(GATE_VALVE_PIN, GPIO.LOW)
    print("Gate Valve state low")

def set_gate_valve_high():
    GPIO.output(GATE_VALVE_PIN, GPIO.HIGH)
    print("Gate Valve state high")

def pick(blow_time, suck_time, move_to_place_time):
    try:
        # Set gate valve low
        set_gate_valve_low()

        # Run the blowing motor for the specified blow time
        kit2.motor3.throttle = 1
        start_time_blow = time.time()
        print(f"Blowing has begun at {time.strftime('%H:%M:%S', time.localtime(start_time_blow))}")
        time.sleep(int(blow_time))
        end_time_blow = time.time()
        print(f"Blowing has finished at {time.strftime('%H:%M:%S', time.localtime(end_time_blow))}. Elapsed time: {end_time_blow - start_time_blow:.2f} seconds")

        set_gate_valve_high()

        # Run the sucking motor for the specified suck time
        start_time_suck = time.time()
        print(f"Sucking has begun at {time.strftime('%H:%M:%S', time.localtime(start_time_suck))}")
        time.sleep(int(suck_time))
        end_time_suck = time.time()
        print(f"Sucking has finished at {time.strftime('%H:%M:%S', time.localtime(end_time_suck))}. Elapsed time: {end_time_suck - start_time_suck:.2f} seconds")

        # Wait for the pick time (motor doesn't shut off during this time)
        time.sleep(move_to_place_time)
    except Exception as e:
        print(f"Error during pick movement: {e}")
        # Handle the error or exit the program

def place():
    try:
        # Move Z-axis down to the specified place_location
        z_distance = -20
        move_z_axis(kit2, z_distance, distance_per_step)

        # Set gate valve low
        set_gate_valve_low()

        # Run the blowing motor for the specified blow time
        kit2.motor3.throttle = 1
        start_time_blow = time.time()
        print(f"Blowing has begun at {time.strftime('%H:%M:%S', time.localtime(start_time_blow))}")
        time.sleep(int(blow_time))
        end_time_blow = time.time()
        print(f"Blowing has finished at {time.strftime('%H:%M:%S', time.localtime(end_time_blow))}. Elapsed time: {end_time_blow - start_time_blow:.2f} seconds")
        kit2.motor3.throttle = 0

    except Exception as e:
        print(f"Error during Z-axis down movement or blowing: {e}")
        # Handle the error or exit the program

def move_z_axis(kit, distance, distance_per_step=0.2):
    try:
        # Determine the direction based on the sign of the distance
        direction = stepper.FORWARD if distance >= 0 else stepper.BACKWARD

        # Calculate the number of steps
        z_steps = int(abs(distance) / distance_per_step)

        # Move the motor in the specified direction
        for i in range(z_steps):
            kit2.stepper1.onestep(direction=direction, style=stepper.DOUBLE)
            time.sleep(0.0001)
    except Exception as e:
        print(f"Error during Z-axis movement: {e}")
        # Handle the error or exit the program

def move_to_home():
    global current_position_gantry_x
    global current_position_gantry_y
    global current_position_gantry_z
    print(f"Last X position was location: {current_position_gantry_x['x']} mm")
    print(f"Last Y position was location: {current_position_gantry_y['y']} mm")
    print(f"Last Z position was location: {current_position_gantry_z['z']} mm")
    
    home_x_distance = home_x - current_position_gantry_x['x']
    home_y_distance = home_y - current_position_gantry_y['y']

    print(f"delta X to move to place postion: {home_x_distance} mm")
    print(f"delta Y to move to place postion: {home_y_distance} mm")

    home_x_steps = int(abs(home_x_distance) / distance_per_step)
    home_y_steps = int(abs(home_y_distance) / distance_per_step)

    # Move xy to place location
    if  home_x_distance > 0:
        direction_1 = stepper.FORWARD
    else:
        direction_1 = stepper.BACKWARD
        
    if  home_y_distance > 0:
        direction_2 = stepper.FORWARD
    else:
        direction_2 = stepper.BACKWARD
        
    home_x_steps = abs(int(home_x_steps))
    home_y_steps = abs(int(home_y_steps))
    
    
    # Move both X and Y axis motors simultaneously
    try:
        for i in range(max(home_x_steps, home_y_steps)):
            if i <= home_x_steps:
                if i >= home_x_steps - 20:
                    kit1.stepper1.onestep(direction=direction_1, style=stepper.MICROSTEP)
                else:
                    kit1.stepper1.onestep(direction=direction_1, style=stepper.SINGLE)
                    
            if i <= home_y_steps:
                if i >= home_y_steps - 20:
                    kit1.stepper2.onestep(direction=direction_2, style=stepper.MICROSTEP)
                else:
                    kit1.stepper2.onestep(direction=direction_2, style=stepper.SINGLE)
        time.sleep(0.0001)
    except Exception as e:
        print(f"Error during motor movement: {e}")
        # Handle the error or exit the program

    # Update the current position
    current_position_gantry_x['x'] = 0
    current_position_gantry_y['y'] = 0

    print("Gantry moved to home position (0, 0)")


# Function to move to a specific (x, y, z) coordinate
def move_to_pick_list(new_x, new_y):
    global current_position_gantry_x
    global current_position_gantry_y
    global current_position_gantry_z
    print(f"Last X position was location: {current_position_gantry_x['x']} mm")
    print(f"Last Y position was location: {current_position_gantry_y['y']} mm")
    print(f"Last Z position was location: {current_position_gantry_z['z']} mm")

    # Bound new_x and new_y within track limits
    new_x = max(start_track_x, min(new_x, track_length_x))
    new_y = max(start_track_y, min(new_y, track_length_y))

    # Calculate the relative movement required for X and Y
    x_distance = new_x - current_position_gantry_x['x']
    y_distance = new_y - current_position_gantry_y['y']

    print(f"delta X is: {x_distance} mm")
    print(f"delta Y is: {y_distance} mm")

    # Calculate the number of steps required for X and Y
    x_steps = int(abs(x_distance) / distance_per_step)
    y_steps = int(abs(y_distance) / distance_per_step)

    if x_steps > 0:
        direction_1 = stepper.FORWARD
    else:
        direction_1 = stepper.BACKWARD
        
    if y_steps > 0:
        direction_2 = stepper.FORWARD
    else:
        direction_2 = stepper.BACKWARD
        
    x_steps = abs(int(x_steps))
    y_steps = abs(int(y_steps))
    

    # Move both X and Y axis motors simultaneously
    try:
        for i in range(max(x_steps, y_steps)):
            if i <= x_steps:
                if i >= x_steps - 20:
                    kit1.stepper1.onestep(direction=direction_1, style=stepper.MICROSTEP)
                else:
                    kit1.stepper1.onestep(direction=direction_1, style=stepper.SINGLE)
                    
            if i <= y_steps:
                if i >= y_steps - 20:
                    kit1.stepper2.onestep(direction=direction_2, style=stepper.MICROSTEP)
                else:
                    kit1.stepper2.onestep(direction=direction_2, style=stepper.SINGLE)
        time.sleep(0.0001)
    except Exception as e:
        print(f"Error during motor movement: {e}")
        # Handle the error or exit the program
    print("In XY postion")
    # Move Z-axis down by 15 mm
    z_distance = -45
    move_z_axis(kit2, z_distance, distance_per_step)
    
    current_position_gantry_x['x'] = new_x
    current_position_gantry_y['y'] = new_y
    print(f"X position is location Currently : {current_position_gantry_x['x']} mm")
    print(f"Y position is location Currently: {current_position_gantry_y['y']} mm")
    # Run the pick sequence
    try:
        pick(blow_time, suck_time, move_to_place_time)
    except Exception as e:
        print(f"Error during pick sequence: {e}")
        # Handle the error or exit the program

    # Move Z-axis back up by 15 mm
    distance = 45
    move_z_axis(kit2, distance, distance_per_step)

def move_to_place_postion(place_x, place_y):
    global current_position_gantry_x
    global current_position_gantry_y
    global current_position_gantry_z
    print(f"Last X position was location: {current_position_gantry_x['x']} mm")
    print(f"Last Y position was location: {current_position_gantry_y['y']} mm")
    print(f"Last Z position was location: {current_position_gantry_z['z']} mm")
    
    x_place_postion = place_x - current_position_gantry_x['x']
    y_place_postion = place_y - current_position_gantry_y['y']

    print(f"delta X to move to place postion: {x_place_postion} mm")
    print(f"delta Y to move to place postion: {y_place_postion} mm")

    x_steps_place = int(abs(x_place_postion) / distance_per_step)
    y_steps_place = int(abs(y_place_postion) / distance_per_step)

    # Move xy to place location
    if x_steps_place > 0:
        direction_1 = stepper.FORWARD
    else:
        direction_1 = stepper.BACKWARD
        
    if y_steps_place > 0:
        direction_2 = stepper.FORWARD
    else:
        direction_2 = stepper.BACKWARD
        
    x_steps_place = abs(int(x_steps_place))
    y_steps_place = abs(int(y_steps_place))
    
    
    # Move both X and Y axis motors simultaneously
    try:
        for i in range(max(x_steps_place, y_steps_place)):
            if i <= x_steps_place:
                if i >= x_steps_place - 20:
                    kit1.stepper1.onestep(direction=direction_1, style=stepper.MICROSTEP)
                else:
                    kit1.stepper1.onestep(direction=direction_1, style=stepper.SINGLE)
                    
            if i <= y_steps_place:
                if i >= y_steps_place - 20:
                    kit1.stepper2.onestep(direction=direction_2, style=stepper.MICROSTEP)
                else:
                    kit1.stepper2.onestep(direction=direction_2, style=stepper.SINGLE)
        time.sleep(0.0001)
    except Exception as e:
        print(f"Error during motor movement: {e}")
        # Handle the error or exit the program
        
    current_position_gantry_x['x'] = place_x
    current_position_gantry_y['y'] = place_y
    current_position_gantry_z['z'] = (z_distance)  # Corrected line
    # Run the Place sequence
    try:
        place()
    except Exception as e:
        print(f"Error during place sequence: {e}")
        # Handle the error or exit the program

    # Update the current position
    print(f"Updated X position: {current_position_gantry_x['x']} mm")
    print(f"Updated Y position: {current_position_gantry_y['y']} mm")
    print(f"Updated Z position: {current_position_gantry_z['z']} mm")

    # Save current position to file
    try:
        with open("current_position_gantry_x.txt", "w") as file_x:
            file_x.write(str(current_position_gantry_x['x']))
        with open("current_position_gantry_y.txt", "w") as file_y:
            file_y.write(str(current_position_gantry_y['y']))
        with open("current_position_gripper_z.txt", "w") as file_z:
            file_z.write(str(current_position_gantry_z['z']))
    except Exception as e:
        print(f"Error writing current position files: {e}")


# Input lists of absolute positions for X and Y
positions_list_x = input("Enter a list of X positions (comma-separated) in millimeters: ").split(',')
positions_list_y = input("Enter a list of Y positions (comma-separated) in millimeters: ").split(',')

# Check if the input lists have the same length
if len(positions_list_x) != len(positions_list_y):
    print("Error: X and Y position lists must have the same length.")
    # Handle the error or exit the program
else:
    # Convert string values to integers
    positions_list_x = [int(position_x) for position_x in positions_list_x]
    positions_list_y = [int(position_y) for position_y in positions_list_y]

    # Move to each position in the lists sequentially
    for new_x, new_y in zip(positions_list_x, positions_list_y):
        move_to_pick_list(new_x, new_y)
        move_to_place_postion(place_x, place_y)
        time.sleep(2)  # Wait for 5 seconds between movements
    move_to_home()

