# -*- coding: utf-8 -*-
"""
Created on Thu Feb  1 15:02:56 2024

@author: Owen Porpora
"""

import time
import board
import RPi.GPIO as GPIO
from adafruit_motorkit import MotorKit
from adafruit_motor import stepper

# Constants
track_length_x = 1000
track_length_y = 800
start_track_x = 0
start_track_y = 0
distance_per_step = 0.2  # Distance moved per step in mm
GATE_VALVE_PIN = 16      # Set the GPIO pin for the gate valve
blow_time = 1            # Blow time in seconds
suck_time = 3            # Suck time in seconds
pick_time = 10           # Pick time in seconds
place_x = 25
place_y = 50
z_distance = 0

# Initialize MotorKit
kit = MotorKit(i2c=board.I2C(0x60))
kit2 = MotorKit(i2c=board.I2C(0x61))

# Load current position from file
try:
    with open("current_position_gantry_x.txt", "r") as file:
        current_position_gantry_x = {'x': int(file.read())}
except FileNotFoundError:
    current_position_gantry_x = {'x': 0}
except Exception as e:
    print(f"Error reading current position file: {e}")
    # Handle the error or exit the program

try:
    with open("current_position_gantry_y.txt", "r") as file:
        current_position_gantry_y = {'y': int(file.read())}
except FileNotFoundError:
    current_position_gantry_y = {'y': 0}
except Exception as e:
    print(f"Error reading current position file: {e}")

try:
    with open("current_position_gripper_z.txt", "r") as file:
        current_position_gantry_z = {'z': int(file.read())}
except FileNotFoundError:
    current_position_gantry_z = {'z': 0}
except Exception as e:
    print(f"Error reading current position file: {e}")
    # Handle the error or exit the program

def set_gate_valve_low():
    GPIO.output(GATE_VALVE_PIN, GPIO.LOW)
    print("Gate Valve state low")

def set_gate_valve_high():
    GPIO.output(GATE_VALVE_PIN, GPIO.HIGH)
    print("Gate Valve state high")

def pick(suck_time, pick_time):
    try:
        # Set gate valve low
        set_gate_valve_low()

        # Run the sucking motor for the specified suck time
        start_time_suck = time.time()
        print(f"Sucking has begun at {time.strftime('%H:%M:%S', time.localtime(start_time_suck))}")
        time.sleep(int(suck_time))
        end_time_suck = time.time()
        print(f"Sucking has finished at {time.strftime('%H:%M:%S', time.localtime(end_time_suck))}. Elapsed time: {end_time_suck - start_time_suck:.2f} seconds")

        # Wait for the pick time (motor doesn't shut off during this time)
        time.sleep(pick_time)
    except Exception as e:
        print(f"Error during pick movement: {e}")
        # Handle the error or exit the program

def place():
    try:
        # Move Z-axis down to the specified place_location
        z_distance = -20
        move_z_axis(kit2, z_distance, distance_per_step)
        
        # Set gate valve low
        set_gate_valve_low()
        
        # Run the blowing motor for the specified blow time
        kit2.motor1.throttle = 1
        start_time_blow = time.time()
        print(f"Blowing has begun at {time.strftime('%H:%M:%S', time.localtime(start_time_blow))}")
        time.sleep(int(blow_time))
        end_time_blow = time.time()
        print(f"Blowing has finished at {time.strftime('%H:%M:%S', time.localtime(end_time_blow))}. Elapsed time: {end_time_blow - start_time_blow:.2f} seconds")
        kit2.motor1.throttle = 0
        
    except Exception as e:
        print(f"Error during Z-axis down movement or blowing: {e}")
        # Handle the error or exit the program

def move_z_axis(kit, distance, distance_per_step=0.2):
    try:
        # Determine the direction based on the sign of the distance
        direction = stepper.FORWARD if distance >= 0 else stepper.BACKWARD

        # Calculate the number of steps
        z_steps = int(abs(distance) / distance_per_step)

        # Move the motor in the specified direction
        for i in range(z_steps):
            kit2.stepper2.onestep(direction=direction, style=stepper.DOUBLE)
            time.sleep(0.0001)
    except Exception as e:
        print(f"Error during Z-axis movement: {e}")
        # Handle the error or exit the program

# Function to move to a specific (x, y, z) coordinate
def move_to(new_x, new_y):
    global current_position_gantry_x
    global current_position_gantry_y
    global current_position_gantry_z
    print(f"Last X position was location: {current_position_gantry_x['x']} mm")
    print(f"Last Y position was location: {current_position_gantry_y['y']} mm")
    print(f"Last Z position was location: {current_position_gantry_z['z']} mm")

    # Bound new_x and new_y within track limits
    new_x = max(start_track_x, min(new_x, track_length_x))
    new_y = max(start_track_y, min(new_y, track_length_y))

    # Calculate the relative movement required for X and Y
    x_distance = new_x - current_position_gantry_x['x']
    y_distance = new_y - current_position_gantry_y['y']

    print(f"delta X is: {x_distance} mm")
    print(f"delta Y is: {y_distance} mm")

    # Calculate the number of steps required for X and Y
    x_steps = int(abs(x_distance) / distance_per_step)
    y_steps = int(abs(y_distance) / distance_per_step)

    # Move both X and Y axis motors simultaneously
    try:
        for i in range(max(x_steps, y_steps)):
            if i < x_steps:
                if x_distance > 0:
                    kit.stepper1.onestep(direction=stepper.FORWARD, style=stepper.DOUBLE)
                elif x_distance < 0:
                    kit.stepper1.onestep(direction=stepper.BACKWARD, style=stepper.DOUBLE)
                else:
                    print("Motor X does not need to move")
            if i < y_steps:
                if y_distance > 0:
                    kit.stepper2.onestep(direction=stepper.FORWARD, style=stepper.DOUBLE)
                elif y_distance < 0:
                    kit.stepper2.onestep(direction=stepper.BACKWARD, style=stepper.DOUBLE)
                else:
                    print("Motor Y does not need to move")
            time.sleep(0.0001)
    except Exception as e:
        print(f"Error during motor movement: {e}")
        # Handle the error or exit the program

    # Move Z-axis down by 15 mm
    z_distance = -15
    move_z_axis(kit2, z_distance, distance_per_step)

    # Run the pick sequence
    try:
        pick(suck_time, pick_time)
    except Exception as e:
        print(f"Error during pick sequence: {e}")
        # Handle the error or exit the program

    # Move Z-axis back up by 15 mm
    distance = 15
    move_z_axis(kit2, distance, distance_per_step)

    x_place_postion = place_x - current_position_gantry_x['x']
    y_place_postion = place_y - current_position_gantry_y['y']

    print(f"delta X is to place postion: {x_place_postion} mm")
    print(f"delta Y is to place postion: {y_place_postion} mm")

    x_steps_place = int(abs(x_place_postion) / distance_per_step)
    y_steps_place = int(abs(y_place_postion) / distance_per_step)

    # Move xy to place loaction
    try:
        for i in range(max(x_steps_place, y_steps_place)):
            if i < x_steps_place:
                if x_place_postion > 0:
                    kit.stepper1.onestep(direction=stepper.FORWARD, style=stepper.DOUBLE)
                elif x_place_postion < 0:
                    kit.stepper1.onestep(direction=stepper.BACKWARD, style=stepper.DOUBLE)
                else:
                    print("Motor X does not need to move")
            if i < y_steps_place:
                if y_place_postion > 0:
                    kit.stepper2.onestep(direction=stepper.FORWARD, style=stepper.DOUBLE)
                elif y_place_postion < 0:
                    kit.stepper2.onestep(direction=stepper.BACKWARD, style=stepper.DOUBLE)
                else:
                    print("Motor Y does not need to move")
            time.sleep(0.0001)
    except Exception as e:
        print(f"Error during Z-axis up movement: {e}")
        # Handle the error or exit the program

    # Run the Place sequence
    try:
        place()
    except Exception as e:
        print(f"Error during pick sequence: {e}")
        # Handle the error or exit the program

    # Update the current position
    current_position_gantry_x['x'] = new_x
    current_position_gantry_y['y'] = new_y
    current_position_gantry_z['z'] = (z_distance)  # Corrected line
    print(f"Updated X position: {current_position_gantry_x['x']} mm")
    print(f"Updated Y position: {current_position_gantry_y['y']} mm")
    print(f"Updated Z position: {current_position_gantry_z['z']} mm")

    # Save current position to file
    try:
        with open("current_position_gantry_x.txt", "w") as file_x:
            file_x.write(str(current_position_gantry_x['x']))
        with open("current_position_gantry_y.txt", "w") as file_y:
            file_y.write(str(current_position_gantry_y['y']))
        with open("current_position_gripper_z.txt", "w") as file_z:
            file_z.write(str(current_position_gantry_z['z']))
    except Exception as e:
        print(f"Error writing current position files: {e}")

# Input lists of absolute positions for X and Y
positions_list_x = input("Enter a list of X positions (comma-separated) in millimeters: ").split(',')
positions_list_y = input("Enter a list of Y positions (comma-separated) in millimeters: ").split(',')

# Check if the input lists have the same length
if len(positions_list_x) != len(positions_list_y):
    print("Error: X and Y position lists must have the same length.")
    # Handle the error or exit the program
else:
    # Convert string values to integers
    positions_list_x = [int(position_x) for position_x in positions_list_x]
    positions_list_y = [int(position_y) for position_y in positions_list_y]

    # Move to each position in the lists sequentially
    for new_x, new_y in zip(positions_list_x, positions_list_y):
        move_to(new_x, new_y)
        time.sleep(5)  # Wait for 5 seconds between movements
